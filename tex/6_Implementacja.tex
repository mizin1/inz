\chapter{Implementacja}

\section{Baza danych}
Warstwa żródła danych została oparta na systemie PostgreSQL. Schemat danych powstał na podstawie modelu fizycznego opsianego w \ref{modelFizyczny}. 

TODO blablabla

\section{Dostęp do danych}
Dostęp do danych został zrealizowany przy użyciu narzędia Hibernate oraz z wykorzystanien wzorca DAO oraz obiektów POJO.

\subsection[Hibernate][Hibernate]{Hibernate} 
Technologa Hibernate została opisana w rozdziale. \ref{hibernate}. Mapowanie obiektowo realacyjne wykonao przy pomocy plików hbm.xml. Na wydruku \ref{praconiwkHbm} oraz \ref{typZadaniaHbm} przestawiono przykłady takich pliku.



\begin{lstlisting}[language=XML,style=outcode,showstringspaces=false,caption=Przykład pliku mapującego Hibernate,label={praconiwkHbm}]
<?xml version="1.0"?>
<hibernate-mapping>
	<class name="pl.waw.mizinski.umowy.model.Pracownik" table="pracownik"
		lazy="true">
		<id name="id" type="java.lang.Long">
			<column name="id" sql-type="int4" />
			<generator class="sequence">
				<param name="sequence">pracownik_sequence</param>
			</generator>
		</id>
		<property name="nazwisko" type="java.lang.String">
			<column name="nazwisko" sql-type="varchar" />
		</property>
		
		<!-- .. -->
		
		<property name="plec" column="plec">
			<type name="org.hibernate.type.EnumType">
				<param name="enumClass">pl.waw.mizinski.umowy.model.enums.Plec</param>
				<param name="type">12</param>
			</type>
		</property>
		
		<!-- .. -->
		
		<many-to-one name="urzadSkarbowy"
			class="pl.waw.mizinski.umowy.model.UrzadSkarbowy">
			<column name="urzad_skarbowy" />
		</many-to-one>
		
		<!-- .. -->
		
		<set name="adresy" table="adres" cascade="all" inverse="true" >
         	<key>
                <column name="pracownik" />
            </key>
            <one-to-many class="pl.waw.mizinski.umowy.model.AdresPracownika" />
        </set>
	</class>
</hibernate-mapping>
\end{lstlisting}

\begin{lstlisting}[language=XML,style=outcode,showstringspaces=false,caption=Przykład pliku mapującego Hibernate wykorzystującego klucz złożony,label={typZadaniaHbm}]
<?xml version="1.0"?>
<hibernate-mapping>
	<class name="pl.waw.mizinski.umowy.model.TypZadania" table="typ_zadania"
		lazy="true">
		<composite-id name="typZadaniaPK" 
			class="pl.waw.mizinski.umowy.model.TypZadaniaPK">
			<key-property name="nazwa" type="java.lang.String">
				<column name="nazwa" />
			</key-property>
				<key-many-to-one name="jednostkaOrganizacyjna" 
					class="pl.waw.mizinski.umowy.model.JednostkaOrganizacyjna">
				<column name="jednostka_organizacyjna" />
			</key-many-to-one>
		</composite-id>
		
		<!-- .. -->
	
	</class>
</hibernate-mapping>
\end{lstlisting}

Na powyższych wydrukach pokazano najczęściej spotykane parametry plików mapujących, są nimi
\begin{itemize}
	\item element opsisujący klucz główny. Wydruk \ref{typZadaniaHbm} zawiera przykład klucza prostego(generowanego za pomocą sekwencji), zaś wydruk \ref{typZadaniaHbm} przykład klucza złożonego,
	\item element mapujący kolumnę tabeli na właściwość klasy na przykładzie kolumny nazwisko,
	\item element mapujący kulumnę tabeli na obiekt typu wylczeniowego(kolumn plec),
	\item element mapujący relację wiele do jednego na inny obiekt domenowy na podstawie klucza obcego(kolumna urzad\_skarbowy),
	\item element mapujący relację jeden do wielu na kolekcję języka Java(zbiór adresów pracownika).
\end{itemize}


\section[Obiekty DAO][Obiekty DAO]{Obiekty DAO}
DAO(ang. \textit{Data Access Object} - Obiekt dostępu do danych) jest to wzorzec projektowy polegający na dostarczeniu interfejsu pozwalającego na dostęp oraz manipulacę danymi. Tworzą one osobną warstwę odzielającą warstwę logiki biznesowej od warstwy źródła danych. Wykorzystywane w systemie obiekty DAO dziedziczą z abstrakcyjnej klasy bazowej, definiującej podstawe operacje jakie można wykonąć na obiektach trwałych. Została ona zaprezentowana na wydruku \ref{abstractDao}.

\begin{lstlisting}[language=Java,style=outcode,showstringspaces=false,caption=Abstrakcyjna klasa DAO,label={abstractDao}]
public abstract class AbstractDao<K extends Serializable, E> {

	protected final Context context;
	private final Class<E> entityClass;

	public AbstractDao(Context context) {
		this.context = context;
		ParameterizedType genericSuperclass = (ParameterizedType) getClass()
				.getGenericSuperclass();
		this.entityClass = 
				(Class<E>) genericSuperclass.getActualTypeArguments()[1];
	}

	protected Session session() {
		return HibernateSessionContext.getHibernateSessionContext(context)
				.getSession();
	}

	public Class<E> getEntityClass() {
		return entityClass;
	}

	public E getById(K id) {
		return (E) session().get(getEntityClass(), id);
	}

	public List<E> getAll() {
		Query query = session().createQuery("from " + getEntityClass().getName());
		return HibernateUtils.queryResult(session(), query);
	}

	public void add(E entity) {
		session().persist(entity);
	}

	public K save(E entity) {
		return (K) session().save(entity);
	}

	public void saveOrUpdate(E entity) {
		session().saveOrUpdate(entity);
	}

	public E merge(E entity) {
		return (E) session().merge(entity);
	}

	public void remove(E entity) {
		session().delete(entity);
	}

	public void remove(K id) {
		E entity = getById(id);
		remove(entity);
	}

	public void remove(Collection<E> entities) {
		for (E entity : entities) {
			remove(entity);
		}
	}

}
\end{lstlisting}

Przedstawiona klasa jest klasą genereczną. Parametryzowana jest dwoma typami danych: typem obiektu mapowaniego na tabelę oraz typem jego klucza. Wydruk \ref{umowaDao} przedstawia przedstawia przykład klasy dziedziczącej po klasie AbastractDao parametryzowanej typami Umowa oraz String(typ klucza głównego - numeru umowy).

\begin{lstlisting}[language=Java,style=outcode,showstringspaces=false,caption=Klasa dao służąca do operacji na umowach,label={umowaDao}]
public class UmowaDao extends AbstractDao<String, Umowa> {

	public UmowaDao(Context context) {
		super(context);
	}
	
	public List<Umowa> getUmowyByPracownik(Pracownik pracownik){
		Query query = session().createQuery("from Umowa u where u.pracownik=?");
		query.setParameter(0, pracownik);
		return HibernateUtils.queryResult(session(), query);
	}
	
	...
}
\end{lstlisting}

Warto zwrócić uwagę na samo zapytanie do bazy danych. Jest ono zapisane w jezyku HQL. Jak widać operuje ono jedynie na obiektach, nie zaś na tabelach i ich kolumnach. Zaletą tego rozwiązania jest to, że niewielkie zmiany w bazie danych(np. zmiana nazwy tabeli badź kolumny) nie muszą oznaczać konieczności zmian zapytań HQL.

\section[Obiekty POJO][Obiekty POJO]{Obiekty POJO}
W zaprezentowanych powyżej przykładach obiekty DAO zwaracały zawsze obiekty twałe. Takie rozwiązanie ma niestety jedną wadę. Podczas korzystania z takich obiektów Hibernate wykonuje wiele odwołań do bazy danych(w celu synchronizacji czy pobrania dodatkowych danych). Powoduje to często niepotrzebny narzut wydajnościowy. Roziązaniem tego problemu są obiekty POJO(ang. \textit{Plain Old Java Object}). Obiekty takie posiadają jedynie konstruktor ustawiający jego pola oraz metody pozwalające na ich odczyt(tzw. gettery). Co najważniejsze POJO w przeciwieństwie do obiektów trwałych nie są powiązane z sesją Hibernate. Wydruk \ref{pojo} zawiera przykład utworzenia obiektu POJO na podstawie elementów z bazy danych.

\begin{lstlisting}[language=Java,style=outcode,showstringspaces=false,caption=Metoda DAO zwracająca listę obiektów POJO,label={pojo}]
public class PracownikDao extends AbstractDao<Long, Pracownik> {

	private final static String PRACOWNIK_IMIE_NAZWISKO_POJO = 
			"pl.waw.mizinski.umowy.pojo" +
			".PracownikImieNazwiskoPOJO(p.id, p.pierwszeImie, p.nazwisko)";

	...

	public List<PracownikImieNazwiskoPOJO> getAllPracownikImieNazwiskoPOJOs() {
		Query query = session().createQuery(
				"select new " + PRACOWNIK_IMIE_NAZWISKO_POJO
						+ "from Pracownik p");
		return HibernateUtils.queryResult(session(), query);
	}
	
	...
}
\end{lstlisting}

Jak łatwo zauważyć obiekty POJO nadają się jedynie od odczytu danych. Zapis odbywa się już przy użyciu obiektów trwałych. Najczęstrym zastosowaniem obiektów POJO w aplikacji jest przekazywanie ich do mechanizmu Velocity w celu przygotowania widoku.

\section[Komunikacja użytkownika z systemem][Komunikacja użytkownika z systemem]{Komunikacja użytkownika z systemem}
Użytkownik komunikuje się z systemem na dwa sposoby. Pierwszym z nich są synchroniczne zapytania HTTP, wykorzystywne są one do przeładowywania widoków, zlecania akcji czy przesyłania formularzy. Drugim sposobem są asynchronicze wywołania AJAX, wwykorzystane tak gdzie wymagana jest wieksza responsywność aplikacji.

\subsection[Walidacja formularzy][Walidacja formularzy]{Walidacja formularzy}
Jedną z najważniejszych części komunikacji z użytkownikiem jest walidajca wprowadzanych przez niego danych. Można ją podzielić na 2 podstawe części:
\begin{itemize}
	\item walidacja po stronie klienta(opcjonalna),
	\item walidacja po stronie serwera(obowiązkowa)
\end{itemize}

\subsubsection{Walidacja po stronie klietna}
Walidacja po stronie klienta pozwala na wyłapanie prostych błędów bez konieczności przesyłania rządania so serwera. Do takich błędów należa m. in. nie uzupełnienie jednego z wymaganych pól, czy wpisanie wartości niezgodnej z zadanym wzorcem. W aplikacji wykorzystano w tym celu komponent dijit.form.ValidationTextBox z pakietu narzędziowego Dojo oraz jego pochodne(np. dijit.form.DateTextBox służący do wprowadzania dat).

\subsubsection{Walidacja po stronie serwera}
Walidacja daych po stronie klienta nie zwalnia programisty z walidacji po strinie serwera. Nawet warunki, które teoretycznie zostały już sprwdzone, powinny po przesłaniu zostać ponownie zweryfikowane. Głównym narzędziem wykorzystanym do walidacji danych po tronie serwera jest modół Ledge Intake. Został on opisany w rozdziale \ref{intake}. Pozwala on deklaratywne zdefiniowanie regół jakie powinny spełniać dane w specjalnym pliku xml. Na wydruku \ref{intakeGroupFactory} pokazano przykładowe reguły poprawności danych użyte w aplikacji zapisane w takim właśnie pliku.

\begin{lstlisting}[language=XML,style=outcode,showstringspaces=false,caption=Konfiguracja modułu Intake,label={intakeGroupFactory}]
<?xml version="1.0" encoding="UTF-8"?>

	<input-data basePackage="pl.waw.mizinski.umowy.">

	<group name="PracownikIntake" key="pracownikIntake" 
		mapToObject="intake.PracownikIntake">
		
		<field name="Nazwisko" key="nazwisko" type="String" displayName="Nazwisko">
			<rule name="required" value="true">To pole jest wymagane</rule>
		</field>
		<field name="Plec" key="plec" type="Enum" displayName="Pierwsze imie">
			<rule name="format" value="pl.waw.mizinski.umowy.model.enums.Plec"/>
		</field>
		<field name="DataUrodzenia" key="dataUrodzenia" type="DateString" 
		displayName="Data urodzenia">
			<rule name="required" value="true">To pole jest wymagane</rule>
			<rule name="format" value="yyyy-MM-dd">
			Prosze podac date w formacie dd-MM-yyyy</rule>
		</field>
		<field name="Pesel" key="pesel" type="String" displayName="Pesel">
			rule name="mask" value="(^\$)|(\\d{11})">
			Niepoprawny format numeru pesel</rule>
		</field>
		
		<!-- ... -->
		
	</group>
		<group name="UmowaIntake" key="umowaIntake" mapToObject="intake.UmowaIntake">
		
		<!-- ... -->
		
		<field name="Wynagrodzenie" key="wynagrodzenie" type="BigDecimal" 
		displayName="Wynagrodznie" formatterStyle="money">
			<rule name="required" value="true">To pole jest wymagane</rule>
			<rule name="invalidNumber">Wprowadzona wartosc jest niepoprawna</rule>
		</field>
	</group>
	
	<!-- ... -->
	
</input-data>
\end{lstlisting}

Na szczególną uwagę zasługuje pole o nazwie Wynagrodzenie. Nie został tam wskazany żaden konkretny wzorzec ale jedynie informacja, że pole należy uzupłnić w formacie właściwym dla pieniędzy. Format ten zostanie określony przez moduł Intake na podstawie ustawień regionalnych aplikacji. 

Niestety nie wszytkie elementy formularza dają się walidować w sposób statyczny. Niezbędne więc stało się wprowadzenie ostatniego kroku weryfikacji danych. Został on umiejscowiony bezpośćrednio w kodzie aplikacji. Walidacji takiej podlegają m. in wzajemny stosunek dat zawarcia, rozpoczęcia i zakończenia umowy, czy numery PESEL oraz NIP pracownika.

\subsection[Technologia AJAX][Technologia AJAX]{Technologia AJAX}
Technologia AJAX została opisana w rozdziale \ref{AJAX}. W aplikacji można wyróżnić 2 klasy przypadków, w których ta technologia miała zastowsowanie:
\begin{itemize}
	\item wymagane jest wykonanie pewnych czynności przez serwer, nie chcemy jednak aby wiązało się z przeładowaniem widoku,
	\item logika jaką powinna wykonać strona kliencka jest zbyt skomplikowana badź wymaga dodatkowych danych.
\end{itemize}
Z pierwszą sytuacją mamy do czynienia w przypadku formularza służącego do dodawania pracownika. W klasycznym przypadku użytkownik ma możliwość wyboru z pośród dostępnych na liście urzedów skarbowych. Może się jednak zdarzyć, że szukanego urzędu na liście po prostu nie będzie. W takim przypadku ma możliwość skorzystania ze specjanego okna dialogowego służącego do dodawania urzędu skarbowego. Ponieważ dodawanie to odbywa się w sposób asynchroniczny, formularz z danymi pracownika nie ulega przeładowniu. Urzytkownik może więc powrócić do jego edycji.

Z sytuacją drugiego typu spotykamy się w trakcie dodawania umowy. W zależności od tego, czy w przypadku wprowadzanej umowy są dostępne dobrowolne składki na ubezpieczenia społeczne, użytkownik powinien mieć mośliwość zdecydowania, czy mają one zostać uwzględnione w umowie. Niestety, zależy to od zbyt wielu czynników co komnplikuje weryfikację tego warunku po stronie klienta. Rozwiązaniem tego problemu jest sprawdzanie dostępnośći dobrowolnych składek za pomocą technilogii AJAX. Po każdej zmianie pracownika badź typu umowy przeglądarka wykonuje sprawdzenie w sposób asynchroniczny i na jego podstawie wyświetla bądź ukrywa część formularza odpowiedzialną za dobrowolne ubezpieczenia społeczne.

\section[Tworzenie widoku][Tworzenie widoku]{Tworzenie widoku}
Widoki zostały stworzone za pomocą kodu HTML, z wykorzystaniem CSS oraz języka JavaScript. Szczególnie przydatna okazała się biblioteka Dojo.

\subsection[Nawigacja][Nawigacja]{Nawigacja}
Do nawigacji został wykorzystany komponent SecureMenu dostarczany wraz z używaną wersją biblioteki ObjectLedge. Ma on format paska znajdującego się na górze akranu. Pozwala nie tylko definiowanie elementów menu ale również, dzięku intergracji z modułem Security, pozwala na sprawdzanie uprawnień do widoków i renderowanie tylko tych jego elementów, które użytkonik ma prawo wyświetlić.

\subsection[Dynamiczne elementy widoku][Dynamiczne elementy widoku]{Dynamiczne elementy widoku}
Zastosowanie języka JavaScript pozwala na tworzenie dynamicznych elementów aplikacji. W aplikacji wykorzystano między innymi elemnty dostarczone wraz z narzędziem Dojo Toolkit takie jak tooltipy czy okna dialogowe. Pojawiły się również elemnty właśnoręcznie oskryptowanie takie jak pojawiająca się na rządanie cześć formularza służąca do wprowadzania adresu korespondencyjnego, czy lista zadań wypełniana automatycznie w zależności od wybranej jednostki i typu zadania. Godnym uwagi elementem są też sortowane tabele, dostępne w użytej wersji ObjectLedga zbudowane z użyciem Dojo Toolkit.

\subsection[Wygląd aplikacji][Wygląd aplikacji]{Wygląd aplikacji}
Wiekszość z wykorzytanych w apliacji elementów pochodziła z pakietu dijit narzędzia Dojo Toolkit. Zaletą tego rozwiązania jest ciekawa paleta stylów pozwalająca na dostosowanie wyglądu użytych kontrolek. Z dostępnych motywów został wybrany schemat tundra łączący odcienie szarości z kolorem niebieski. Pozostałe elementy dotyczące prezentacji daych zostały wydzielone do osobnego pliku css.

\subsection[Wykorzystanie Velocity][Wykorzystanie Velocity]{Wykorzystanie Velocity}
Do generacji dokumentów wykorzystano mechanizm Velocity. Możliwości tego mechazmu ilustruje makro powstałe podczas tworzenia aplikacji. Zostało ono pokazane na wydruku \ref{velocity}.

\begin{lstlisting}[language=XML,style=outcode,showstringspaces=false,caption=Definicja makra w Velocity,label={velocity}]
#macro (displayAddress $adres) 
	#if ($adres.ulica)
		#if($adres.miejscowosc == $adres.poczta)
			#set($displayMiescowosc = false)
		#else
			#set($displayMiescowosc = true)
		#end
	#else
		#set($displayMiescowosc = true)
	#end
	#if ($displayMiescowosc) $adres.miejscowosc #end
	$!adres.ulica $adres.nrDomu 
	#if($adres.nrMieszkania) m. $adres.nrMieszkania #end
	<br>
	$adres.kodPocztowy $adres.poczta, $!adres.panstwo.nazwa
#end
\end{lstlisting}

Zadaniem powyższego makra jest wyświetlenie adresu. Adres taki może zaczynać się nazwą miejscowości(dzieje się tak, gdy nie została zefiniowana ulica badź miejscowość jest różna od poczty). Zostało to zrealizowne za pomocą instukcji warunkowych \#if oraz instrukcji przypisania \#set. Innym opcjonalnym elementem adresu jest ulica. Do wyświetlenia tego elementu posłużono się konstrukcją \$!, która nie generuje wyjścia w przypadku napotkania wartości null.

\section[Generacja plików pdf][Generacja plików pdf]{Generacja plików pdf}
Drukownie do plików pdf zaimplementowano za pomocą dostarczanego razem z ObjectLedge modułu FOP(ang. \textit{Formatting Objects Processor}). Pozwala on na generację dokumentów na podstawie zdefiniowanych wcześniej w formacie xls szablonów oraz danych zserializowanych do formatu xml. Do serializacji danych posłużył moduł Velocity.

\section[Automatyczna generacja rachunków][Automatyczna generacja rachunków]{Automatyczna generacja rachunków}
Jednym z zadań aplikacji jest automatyczna generacja rachunków do umów znajdujących się w systemie. Została ona zaimplementowana na podstawie mechanizm schedulera narzędzia ObjectLedge. Pozwala ono zdefiniownie cyklicznie uruchamianych zadań, których częstotliwość można zdefiniować za pomocą wyrażeń unixowego demona cron \cite{link do man cron}. 

\section[Mechanizm autoryzacji][Mechanizm autoryzacji]{Mechanizm autoryzacji}

TODO

\section[Testowanie aplikacji][Testowanie aplikacji]{Testowanie aplikacji}

TODO
